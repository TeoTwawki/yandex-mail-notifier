import {
    CONNECTION_NAME,
    DISPATCH,
    UPDATE_STATE
} from './constants';

let connection,
    store,
    actions,
    onDisconnect;

// eslint-disable-next-line consistent-return
function handleMessages(msg, sender, cb) {
    if (msg.type === DISPATCH) {
        actions[msg.actionName](msg.data);
    }
    else if (msg.type === UPDATE_STATE) {
        cb(store.getState());
        // need to keep channel open, https://developer.chrome.com/extensions/runtime#event-onMessage
        return true;
    }
}

function sendState() {
    connection.postMessage({
        type: UPDATE_STATE,
        data: store.getState()
    });
}

// allow other parts of the app to reuse the store, e.g. popup
function handleConnection(con) {
    if (con.name !== CONNECTION_NAME) {
        return;
    }

    connection = con;

    // send updated state to other parts of the app on every change
    const unsubscribe = store.subscribe(sendState);

    // unsubscribe on disconnect
    connection.onDisconnect.addListener(() => {
        unsubscribe();

        onDisconnect && onDisconnect();
    });

    // send initial state
    sendState();
}

export default function (options) {
    store = options.store;
    actions = options.actions;
    onDisconnect = options.onDisconnect;

    chrome.runtime.onConnect.addListener(handleConnection);
    chrome.runtime.onMessage.addListener(handleMessages);

    return store;
}
